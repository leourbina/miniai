# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_convolutions.ipynb.

# %% auto 0
__all__ = ['def_device', 'im2col', 'conv2d_col', 'conv', 'to_device', 'collate_device']

# %% ../nbs/07_convolutions.ipynb 3
import torch
from torch import nn
from torch.utils.data import default_collate
from typing import Mapping

from .training import * 
from .datasets import * 

# %% ../nbs/07_convolutions.ipynb 27
def im2col(kernel, n, stride=1, device='cpu'):
    """
    Unrolls a square kernel matrix such that when multplied by a flattened image vector, 
    it results in the flattened convolution.
    
    First let's assume stride 1.
    
    Takes a `(k,k)` kernel and a image dimension `n` and turns it into a matrix of dimensions
    `((n-k+1)^2, n^2)`
    """
    k = kernel.shape[0]
    dim = n-k+1
    
    result = torch.zeros(dim**2, n**2).to(device=device)
    for i in range(dim):
        for j in range(dim):
            idx = dim *i + j
            for t in range(k):
                result[idx, t*n + i*n + j : t*n + i*n + j + k] = kernel[t]

    return result

def conv2d_col(img, kernel, device='cpu'):
    n = img.shape[0]
    k = kernel.shape[0]
    kernel_col = im2col(kernel, n, device=device)
    return (kernel_col @ img.view(-1)).view(n-k+1, n-k+1)

# %% ../nbs/07_convolutions.ipynb 61
def conv(ni, nf, ks=3, stride=2, act=nn.ReLU):
    res = nn.Conv2d(ni, nf, stride=stride, kernel_size=ks, padding=ks//2)
    if act: res = nn.Sequential(res, nn.ReLU())
    return res

# %% ../nbs/07_convolutions.ipynb 66
def_device = 'mps' if torch.backends.mps.is_available() else 'cuda' if torch.cuda.is_available() else 'cpu'

def to_device(x, device=def_device):
    if isinstance(x, torch.Tensor): return x.to(device)
    if isinstance(x, Mapping): return {k:v.to(device) for k, v in x.items()}
    return type(x)(to_device(o, device) for o in x)

def collate_device(b): return to_device(default_collate(b))
