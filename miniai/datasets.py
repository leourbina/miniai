# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_datasets.ipynb.

# %% ../nbs/05_datasets.ipynb 2
from __future__ import annotations
import math
import logging, pickle, gzip, os, time, shutil, torch
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from pathlib import Path
from operator import itemgetter
from itertools import zip_longest
import fastcore.all as fc
from torch.utils.data import default_collate
from .training import * 

from torch import tensor, nn, optim
from torch.utils.data import DataLoader
import torch.nn.functional as F
from datasets import load_dataset, load_dataset_builder

import torchvision.transforms.functional as TF
from fastcore.test import test_close

# %% auto 0
__all__ = ['inplace', 'collate_dict', 'show_image', 'subplots', 'get_grid', 'show_images', 'get_dls', 'DataLoaders']

# %% ../nbs/05_datasets.ipynb 21
def inplace(f):
    def _f(b):
        f(b)
        return b
    return _f

# %% ../nbs/05_datasets.ipynb 25
def collate_dict(ds):
    get = itemgetter(*ds.features)
    def _fb(b): return get(default_collate(b))
    return _fb

# %% ../nbs/05_datasets.ipynb 29
@fc.delegates(plt.Axes.imshow)
def show_image(im, ax=None, figsize=None, title=None, noframe=True, **kwargs):
    "Shows a PIL or Pytorch image on ax"
    if fc.hasattrs(im, ('cpu', 'permute', 'detach')):
        im = im.detach().cpu() # Move the image off the accelerator
        if len(im.shape) == 3 and im.shape[0] < 5: im = im.permute(1, 2, 0)
    elif not isinstance(im, np.ndarray): im=np.array(im)
    if im.shape[-1] == 1: im=im[...,0]
    if ax is None: _, ax = plt.subplots(figsize=figsize)
    ax.imshow(im, **kwargs)
    if title is not None: ax.set_title(title)
    ax.set_xticks([])
    ax.set_yticks([])
    if noframe: ax.axis('off')
    return ax

# %% ../nbs/05_datasets.ipynb 31
@fc.delegates(plt.subplots, keep=True)
def subplots(
    nrows: int=1, 
    ncols: int=1, 
    figsize:tuple=None, 
    imsize:int=3, 
    subtitle:str=None,
    **kwargs):
    """A figure and set of subplots to display images of `imsize` inches"""
    if figsize is None: figsize=(ncols*imsize, nrows*imsize)
    fig, ax = plt.subplots(nrows, ncols, figsize=figsize, **kwargs)
    if subtitle is not None: fig.subtitle(subtitle)
    if nrows*ncols==1: ax = np.array([ax])
    return fig, ax

# %% ../nbs/05_datasets.ipynb 35
@fc.delegates(subplots)
def get_grid(
    n:int,
    nrows:int=None,
    ncols:int=None,
    title:str=None,
    weight:str='bold',
    size:int=14,
    **kwargs):
    """Return a grid of `n` axes, `rows`, by `cols`"""
    if nrows: ncols = ncols or int(np.floor(n/nrows))
    elif ncols: nrows = nrows or int(np.ceil(n/ncols))
    else:
        nrows = int(math.sqrt(n))
        ncols = int(np.ceil(n/nrows))
    fig, axs = subplots(nrows, ncols, **kwargs)
    for i in range(n, nrows*ncols): axs.flat[i].set_axis_off()
    if title is not None: fig.suptitle(title, weight=weight, size=size)
    return fig, axs

# %% ../nbs/05_datasets.ipynb 37
@fc.delegates(subplots)
def show_images(ims:list,
                nrows:int|None=None,
                ncols:int|None=None,
                titles:list|None=None,
                **kwargs):
    "Show all images `ims` as subplots with `rows` using `titles`"
    axs = get_grid(len(ims), nrows, ncols, **kwargs)[1].flat
    for im, t, ax in zip_longest(ims, titles or [], axs): show_image(im, ax=ax, title=t)


# %% ../nbs/05_datasets.ipynb 41
def get_dls(train_ds, valid_ds, bs, **kwargs):
    return (
        DataLoader(train_ds, batch_size=bs, shuffle=True, **kwargs),
        DataLoader(valid_ds, batch_size=bs*2, **kwargs))

class DataLoaders:
    def __init__(self, *dls): self.train,self.valid = dls[:2]

    @classmethod
    def from_dd(cls, dd, bs, as_tuple=True, **kwargs):
        f = collate_dict(dd['train'])
        train_dl, valid_dl, *_ = dd.values()
        args = get_dls(train_dl, valid_dl, bs=bs, collate_fn=f, **kwargs)
        return cls(*args)
